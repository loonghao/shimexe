name: Release

# This workflow handles release-please automation and publishing
# It creates releases when changes are pushed to main, and publishes binaries when releases are created
on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write # Required for creating releases and uploading artifacts
  pull-requests: write # Required for release-please
  issues: write # Required for release-please
  id-token: write # Required for trusted publishing

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTFLAGS: -D warnings

jobs:
  # First job: Run release-please to create releases and tags
  release-please:
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      releases_created: ${{ steps.release.outputs.releases_created }}
    steps:
      - name: "Cleanup stale 'autorelease: pending' labels on merged PRs"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const q = `repo:${owner}/${repo} label:\"autorelease: pending\" is:pr is:merged`;
            const resp = await github.rest.search.issuesAndPullRequests({ q });
            for (const pr of resp.data.items || []) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: pr.number,
                  name: 'autorelease: pending',
                });
                core.info(`Removed 'autorelease: pending' from #${pr.number}`);
              } catch (e) {
                core.warning(`Label cleanup failed for #${pr.number}: ${e.message}`);
              }
            }
      - name: Run release-please
        uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  upload-assets:
    name: Upload release assets
    needs: release-please
    # Only run if release was created
    if: ${{ needs.release-please.outputs.release_created }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          # Linux targets
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-22.04
          - target: x86_64-unknown-linux-musl
            os: ubuntu-22.04
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-22.04
          - target: aarch64-unknown-linux-musl
            os: ubuntu-22.04
          # macOS targets
          - target: x86_64-apple-darwin
            os: macos-13
          - target: aarch64-apple-darwin
            os: macos-13
          # Windows targets
          - target: x86_64-pc-windows-msvc
            os: windows-2022
          - target: aarch64-pc-windows-msvc
            os: windows-2022
    timeout-minutes: 60
    steps:
      - name: Debug release info
        run: |
          echo "Tag: ${{ github.ref_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event: ${{ github.event_name }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - uses: taiki-e/setup-cross-toolchain-action@v1
        with:
          target: ${{ matrix.target }}
        if: startsWith(matrix.os, 'ubuntu') && !contains(matrix.target, '-musl')

      - uses: taiki-e/install-action@v2
        with:
          tool: cross
        if: contains(matrix.target, '-musl')

      - run: echo "RUSTFLAGS=${RUSTFLAGS} -C target-feature=+crt-static" >> "${GITHUB_ENV}"
        if: endsWith(matrix.target, 'windows-msvc')

      - uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: shimexe
          target: ${{ matrix.target }}
          tar: all
          zip: windows
          token: ${{ secrets.GITHUB_TOKEN }}

  publish-packages:
    name: Publish to package managers
    needs: [release-please, upload-assets]
    runs-on: ubuntu-22.04
    if: ${{ needs.release-please.outputs.release_created }}
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract version from release
        id: version
        run: |
          VERSION="${{ needs.release-please.outputs.tag_name }}"
          VERSION=${VERSION#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Setup Node.js (for jq)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Wait for release assets
        run: |
          echo "Waiting for release assets to be available..."
          sleep 30

          # Check if all expected assets are available
          EXPECTED_ASSETS=(
            "shimexe-${{ steps.version.outputs.version }}-x86_64-pc-windows-msvc.zip"
            "shimexe-${{ steps.version.outputs.version }}-aarch64-pc-windows-msvc.zip"
            "shimexe-${{ steps.version.outputs.version }}-x86_64-apple-darwin.tar.xz"
            "shimexe-${{ steps.version.outputs.version }}-aarch64-apple-darwin.tar.xz"
            "shimexe-${{ steps.version.outputs.version }}-x86_64-unknown-linux-gnu.tar.xz"
            "shimexe-${{ steps.version.outputs.version }}-aarch64-unknown-linux-gnu.tar.xz"
          )

          for asset in "${EXPECTED_ASSETS[@]}"; do
            echo "Checking for asset: $asset"
            curl -f -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ needs.release-please.outputs.tag_name }}" \
              | jq -r '.assets[].name' | grep -q "$asset" || {
                echo "Asset $asset not found, waiting..."
                sleep 10
              }
          done

      - name: Publish to Scoop bucket
        if: vars.SCOOP_BUCKET_REPO != ''
        run: |
          chmod +x scripts/publish-packages.sh
          ./scripts/publish-packages.sh \
            --version "${{ steps.version.outputs.version }}" \
            --github-token "${{ secrets.GITHUB_TOKEN }}" \
            --publish-scoop \
            --scoop-bucket-repo "${{ vars.SCOOP_BUCKET_REPO }}"

      - name: Publish to Homebrew tap
        if: vars.HOMEBREW_TAP_REPO != ''
        run: |
          chmod +x scripts/publish-packages.sh
          ./scripts/publish-packages.sh \
            --version "${{ steps.version.outputs.version }}" \
            --github-token "${{ secrets.GITHUB_TOKEN }}" \
            --publish-homebrew \
            --homebrew-tap-repo "${{ vars.HOMEBREW_TAP_REPO }}"



      - name: Update local package files
        run: |
          # Update local package manifests with new version and hashes
          chmod +x scripts/publish-packages.sh
          ./scripts/publish-packages.sh \
            --version "${{ steps.version.outputs.version }}" \
            --github-token "${{ secrets.GITHUB_TOKEN }}" \
            --dry-run

      - name: Configure Git for PR creation
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create PR for package updates
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: update package manifests to v${{ steps.version.outputs.version }}"
          title: "chore: update package manifests to v${{ steps.version.outputs.version }}"
          body: |
            This PR updates the local package manifests with the new version and asset hashes.

            Changes:
            - Updated Scoop manifest with new version and hashes
            - Updated Homebrew formula with new version and hashes
            - Updated Chocolatey template with new version

            This is an automated PR created after the release workflow.
          branch: "update-packages-v${{ steps.version.outputs.version }}"
          delete-branch: true
          committer: "github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
          author: "github-actions[bot] <github-actions[bot]@users.noreply.github.com>"

  publish-chocolatey:
    name: Publish to Chocolatey
    needs: [release-please, upload-assets]
    runs-on: windows-2025
    if: ${{ needs.release-please.outputs.release_created }}
    timeout-minutes: 20
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract version from release
        id: version
        shell: pwsh
        run: |
          $VERSION = "${{ needs.release-please.outputs.tag_name }}" -replace '^v', ''
          echo "version=$VERSION" >> $env:GITHUB_OUTPUT
          Write-Host "Version: $VERSION"

      - name: Wait for release assets
        shell: pwsh
        run: |
          Write-Host "Waiting for release assets to be available..."
          Start-Sleep -Seconds 30

          $expectedAssets = @(
            "shimexe-${{ steps.version.outputs.version }}-x86_64-pc-windows-msvc.zip"
          )

          foreach ($asset in $expectedAssets) {
            Write-Host "Checking for asset: $asset"
            $headers = @{
              "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
              "Accept" = "application/vnd.github.v3+json"
            }

            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ needs.release-please.outputs.tag_name }}" -Headers $headers
            $assetExists = $release.assets | Where-Object { $_.name -eq $asset }

            if (-not $assetExists) {
              Write-Host "Asset $asset not found, waiting..."
              Start-Sleep -Seconds 10
            }
          }

      - name: Setup Chocolatey
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
          iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

      - name: Publish Chocolatey package
        shell: pwsh
        env:
          CHOCOLATEY_API_KEY: ${{ secrets.CHOCOLATEY_API_KEY }}
        run: |
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
          if (-not $env:CHOCOLATEY_API_KEY) {
            Write-Host "CHOCOLATEY_API_KEY not set, skipping Chocolatey publishing"
            exit 0
          }
          .\scripts\publish-chocolatey.ps1 `
            -Version "${{ steps.version.outputs.version }}" `
            -GitHubToken "${{ secrets.GITHUB_TOKEN }}" `
            -PublishChocolatey `
            -ChocolateyApiKey $env:CHOCOLATEY_API_KEY

  update-package-managers:
    name: Update package managers
    needs: [release-please, upload-assets]
    runs-on: ubuntu-latest
    if: ${{ needs.release-please.outputs.release_created }}
    steps:
      - name: Checkout shimexe
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          VERSION="${{ needs.release-please.outputs.tag_name }}"
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Calculate file hashes
        id: hashes
        run: |
          # Function to get file hash from GitHub release
          get_hash() {
            local file_url="https://github.com/loonghao/shimexe/releases/download/v${{ steps.version.outputs.version }}/$1"
            echo "Getting hash for: $file_url"
            curl -sL "$file_url" | sha256sum | cut -d' ' -f1
          }

          # Calculate hashes for all platforms
          WIN_X64_HASH=$(get_hash "shimexe-${{ steps.version.outputs.version }}-x86_64-pc-windows-msvc.zip")
          WIN_ARM64_HASH=$(get_hash "shimexe-${{ steps.version.outputs.version }}-aarch64-pc-windows-msvc.zip")
          MAC_X64_HASH=$(get_hash "shimexe-${{ steps.version.outputs.version }}-x86_64-apple-darwin.tar.xz")
          MAC_ARM64_HASH=$(get_hash "shimexe-${{ steps.version.outputs.version }}-aarch64-apple-darwin.tar.xz")
          LINUX_X64_HASH=$(get_hash "shimexe-${{ steps.version.outputs.version }}-x86_64-unknown-linux-gnu.tar.xz")
          LINUX_ARM64_HASH=$(get_hash "shimexe-${{ steps.version.outputs.version }}-aarch64-unknown-linux-gnu.tar.xz")

          # Output hashes
          echo "win_x64_hash=$WIN_X64_HASH" >> $GITHUB_OUTPUT
          echo "win_arm64_hash=$WIN_ARM64_HASH" >> $GITHUB_OUTPUT
          echo "mac_x64_hash=$MAC_X64_HASH" >> $GITHUB_OUTPUT
          echo "mac_arm64_hash=$MAC_ARM64_HASH" >> $GITHUB_OUTPUT
          echo "linux_x64_hash=$LINUX_X64_HASH" >> $GITHUB_OUTPUT
          echo "linux_arm64_hash=$LINUX_ARM64_HASH" >> $GITHUB_OUTPUT

      - name: Update Scoop bucket
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_PLZ_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Clone scoop bucket
          git clone https://github.com/loonghao/scoop-bucket.git
          cd scoop-bucket

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update shimexe manifest with version and hashes
          cat > bucket/shimexe.json << EOF
          {
              "version": "${{ steps.version.outputs.version }}",
              "description": "The Modern Executable Shim Manager - Transform any executable into a smart, portable shim with HTTP download support",
              "homepage": "https://github.com/loonghao/shimexe",
              "license": "MIT",
              "architecture": {
                  "64bit": {
                      "url": "https://github.com/loonghao/shimexe/releases/download/v${{ steps.version.outputs.version }}/shimexe-${{ steps.version.outputs.version }}-x86_64-pc-windows-msvc.zip",
                      "hash": "${{ steps.hashes.outputs.win_x64_hash }}",
                      "extract_dir": "shimexe-${{ steps.version.outputs.version }}-x86_64-pc-windows-msvc"
                  },
                  "arm64": {
                      "url": "https://github.com/loonghao/shimexe/releases/download/v${{ steps.version.outputs.version }}/shimexe-${{ steps.version.outputs.version }}-aarch64-pc-windows-msvc.zip",
                      "hash": "${{ steps.hashes.outputs.win_arm64_hash }}",
                      "extract_dir": "shimexe-${{ steps.version.outputs.version }}-aarch64-pc-windows-msvc"
                  }
              },
              "bin": "shimexe.exe",
              "checkver": {
                  "github": "https://github.com/loonghao/shimexe"
              },
              "autoupdate": {
                  "architecture": {
                      "64bit": {
                          "url": "https://github.com/loonghao/shimexe/releases/download/v\$version/shimexe-\$version-x86_64-pc-windows-msvc.zip",
                          "extract_dir": "shimexe-\$version-x86_64-pc-windows-msvc"
                      },
                      "arm64": {
                          "url": "https://github.com/loonghao/shimexe/releases/download/v\$version/shimexe-\$version-aarch64-pc-windows-msvc.zip",
                          "extract_dir": "shimexe-\$version-aarch64-pc-windows-msvc"
                      }
                  }
              },
              "notes": [
                  "shimexe has been installed successfully!",
                  "",
                  "Quick start:",
                  "  shimexe init --examples",
                  "  shimexe add mytool --path https://example.com/tool.exe",
                  "",
                  "For more information, visit: https://github.com/loonghao/shimexe"
              ]
          }
          EOF

          # Commit and push if changes
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add bucket/shimexe.json
            git commit -m "chore: update shimexe to v${{ steps.version.outputs.version }}

          - Update version to ${{ steps.version.outputs.version }}
          - Update download URLs and file hashes
          - Automatic update from release workflow"
            git push
          fi

      - name: Update Homebrew tap
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_PLZ_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Clone homebrew tap
          git clone https://github.com/loonghao/homebrew-tap.git
          cd homebrew-tap

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update shimexe formula with version and hashes
          cat > Formula/shimexe.rb << 'EOF'
          class Shimexe < Formula
            desc "The Modern Executable Shim Manager"
            homepage "https://github.com/loonghao/shimexe"
            version "${{ steps.version.outputs.version }}"
            license "MIT"

            if OS.mac?
              if Hardware::CPU.arm?
                url "https://github.com/loonghao/shimexe/releases/download/v#{version}/shimexe-#{version}-aarch64-apple-darwin.tar.xz"
                sha256 "${{ steps.hashes.outputs.mac_arm64_hash }}"
              else
                url "https://github.com/loonghao/shimexe/releases/download/v#{version}/shimexe-#{version}-x86_64-apple-darwin.tar.xz"
                sha256 "${{ steps.hashes.outputs.mac_x64_hash }}"
              end
            elsif OS.linux?
              if Hardware::CPU.arm?
                url "https://github.com/loonghao/shimexe/releases/download/v#{version}/shimexe-#{version}-aarch64-unknown-linux-gnu.tar.xz"
                sha256 "${{ steps.hashes.outputs.linux_arm64_hash }}"
              else
                url "https://github.com/loonghao/shimexe/releases/download/v#{version}/shimexe-#{version}-x86_64-unknown-linux-gnu.tar.xz"
                sha256 "${{ steps.hashes.outputs.linux_x64_hash }}"
              end
            end

            def install
              bin.install "shimexe"

              # Install shell completions if available
              if (buildpath/"completions").exist?
                bash_completion.install "completions/shimexe.bash" => "shimexe"
                zsh_completion.install "completions/_shimexe"
                fish_completion.install "completions/shimexe.fish"
              end

              # Install man page if available
              if (buildpath/"man").exist?
                man1.install "man/shimexe.1"
              end
            end

            test do
              system "#{bin}/shimexe", "--version"
              system "#{bin}/shimexe", "--help"

              # Test basic functionality
              system "#{bin}/shimexe", "init"
              assert_predicate testpath/".shimexe", :exist?
            end
          end
          EOF

          # Commit and push if changes
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add Formula/shimexe.rb
            git commit -m "chore: update shimexe to v${{ steps.version.outputs.version }}

          - Update version to ${{ steps.version.outputs.version }}
          - Update download URLs and file hashes
          - Automatic update from release workflow"
            git push
          fi

